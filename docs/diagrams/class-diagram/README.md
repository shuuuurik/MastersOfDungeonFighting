## Диаграмма классов: детальное описание архитектуры

Данная диаграмма классов визуализирует статическую структуру системы MastersOfDungeonFighting, демонстрируя ключевые классы, интерфейсы, перечисления, их атрибуты, методы и взаимосвязи. Она подчеркивает применение принципов объектно-ориентированного проектирования и различных паттернов для создания гибкой, расширяемой и поддерживаемой архитектуры игры.

### 1. Пакет `types` (Domain Data)

Пакет `types` представляет собой ядро предметной области игры, определяя все основные структуры данных и сущности. Содержит в себе основные компоненты, из которых состоит игровой мир и его состояние.

* **`BaseEntity`**: Центральный интерфейс, служащий основой для всех игровых объектов (игрока, врагов, предметов). Он определяет общие характеристики, такие как ID, позиция, статистика и внешний вид. `EnemyEntity` и `OtherEntity` являются его специализированными реализациями.
* **`GameState`**: Главный контейнер, который хранит текущее состояние всей игры, включая карту, текущее игровое поле, данные игрока, список врагов и общие параметры игры.
* **Структуры карты**: Интерфейсы `Position`, `Tile`, `GameField` и `GameMap` описывают пространственное представление игрового мира, от отдельных клеток до многоуровневой карты.

### 2. Пакет `services` (Game Logic)

Пакет `services` инкапсулирует основную игровую логику и правила, отделяя их от представления и хранения данных. Эти классы отвечают за динамику игрового процесса.

* **`GameEngine`**: Является координатором всей игровой логики. Он управляет последовательностью ходов, обрабатывает ввод игрока, инициирует действия врагов, рассчитывает результаты боев и обновляет `GameState`. `GameEngine` слабо связан с конкретными реализациями поведения и состояний врагов благодаря использованию паттернов.
* **`EntityManager`**: Отвечает за управление всеми сущностями в игре: их создание, размещение на карте и предоставление интерфейсов для взаимодействия с ними. Для создания сущностей он использует паттерн "абстрактная фабрика".
* **`MapService`**: Управляет игровыми картами и полями, предоставляя методы для навигации, проверки валидности перемещений и взаимодействия с окружением. Использует паттерн "строитель" карт для их генерации.

Классы в этом пакете активно взаимодействуют с данными из пакета `types` и оркестрируют использование классов из пакета `patterns` для реализации сложного поведения.

### 3. Пакет `patterns` (Design Patterns)

Пакет `patterns` является ключевым для обеспечения гибкости, расширяемости и модульности архитектуры. Здесь собраны реализации различных поведенческих и порождающих паттернов.

* **Strategy Pattern (`strategy`)**: Позволяет динамически изменять алгоритмы поведения врагов (например, `AggressiveBehavior`, `PassiveBehavior`, `FearfulBehavior`), инкапсулируя каждый алгоритм в отдельный класс. Это упрощает добавление новых типов поведения без изменения кода, использующего эти стратегии.
* **Decorator Pattern (`decorator`)**: Расширяет функциональность объектов `BehaviorStrategy` во время выполнения. `ConfusedBehavior`, например, может временно изменять стандартную стратегию врага, заставляя его двигаться случайным образом, не затрагивая его исходное поведение.
* **Builder Pattern (`builder`)**: Упрощает процесс создания сложных объектов, таких как `GameMap`. `MapBuilder` позволяет создавать карты с различными параметрами (размеры, источники данных) пошагово, повышая читаемость и контроль над процессом инициализации.
* **Abstract Factory Pattern (`factory`)**: Предоставляет интерфейс для создания семейств взаимосвязанных объектов (`Entity`) без указания их конкретных классов. `FantasyEntityFactory` и `ForestEntityFactory` позволяют легко переключать "тему" игры, создавая разных врагов для каждого стиля.
* **Prototype Pattern (`prototype`)**: Используется для создания новых объектов путем копирования существующего экземпляра. `ReplicatingEntity` использует этот паттерн для клонирования себя, что критично для механики размножающихся врагов.
* **Command Pattern (`command`)**: Инкапсулирует запрос как объект, позволяя параметризовать клиентов различными запросами, ставить их в очередь, логировать или отменять операции. `MoveCommand`, `AttackCommand`, `ConfuseCommand` и `WaitCommand` представляют действия игрока, которые затем выполняются `CommandInvoker`.
* **State Pattern (`state`)**: Позволяет объекту изменять своё поведение при изменении его внутреннего состояния. Мобы используют состояния (`NormalState`, `PanicState`, `TrackingState`, `PatrolState`) для адаптивного изменения своей стратегии поведения в зависимости от здоровья, близости игрока и других факторов.

Использование этих паттернов значительно снижает связанность между компонентами, делает систему более предсказуемой и облегчает её тестирование и развитие.

### 4. Пакет `components` (UI)

Пакет `components` отвечает за пользовательский интерфейс игры, то есть за отображение информации игроку и обработку его ввода.

* **`App`**: Главный компонент приложения, который инициирует `GameEngine` и связывает его с UI-компонентами. Он также отвечает за обработку пользовательского ввода с клавиатуры, преобразуя его в команды для игрового движка.
* **`GameBoard`**: Отображает текущее состояние игрового поля и сущностей на нем, визуализируя данные из `GameState`.
* **`StatusPanel`**: Отображает текущие статистические данные игрока и другую важную информацию из `GameState`.

Компоненты UI имеют **слабую связанность** с игровой логикой; они в основном "читают" состояние и "отправляют" команды, не содержа сложной игровой логики внутри себя. Это обеспечивает чистое разделение обязанностей и позволяет легко менять внешний вид без влияния на ядро игры.